<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jose Armesto&#39;s Blog</title>
    <link>https://fiunchinho.github.io/blog/tags/unit-testing/index.xml</link>
    <description>Recent content on Jose Armesto&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-es</language>
    <copyright>Powered by [Hugo](//gohugo.io). Theme by [PPOffice](http://github.com/ppoffice).</copyright>
    <atom:link href="https://fiunchinho.github.io/blog/tags/unit-testing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Mis impresiones sobre el debate #isTDDDead</title>
      <link>https://fiunchinho.github.io/blog/mis-impresiones-sobre-el-debate-istdddead/</link>
      <pubDate>Fri, 23 May 2014 20:35:44 +0000</pubDate>
      
      <guid>https://fiunchinho.github.io/blog/mis-impresiones-sobre-el-debate-istdddead/</guid>
      <description>&lt;p&gt;El &lt;a title=&#34;Yo no soy DHH. Long live TDD&#34; href=&#34;http://blog.armesto.net/yo-no-soy-dhh-long-live-tdd/&#34; target=&#34;_blank&#34;&gt;debate sobre si TDD está muerto&lt;/a&gt; o no sigue &lt;em&gt;vivito y coleando&lt;/em&gt;, y tras una guerra fría de artículos por ambas partes, ahora el intercambio de opiniones se ha pasado a un formato de &lt;a title=&#34;isTDDDead&#34; href=&#34;http://martinfowler.com/articles/is-tdd-dead/&#34; target=&#34;_blank&#34;&gt;vídeo debate&lt;/a&gt; donde Martin Fowler, Kent Beck y el mismísimo David Heinemeier Hansson hablan sobre el tema.&lt;/p&gt;

&lt;p&gt;La verdad es que cuando anunciaron que Kent Beck iba a enfrentarse a David Heinemeier sobre el tema TDD, me alegré bastante por ver a gente tan buena en esto que hacemos debatiendo sobre distintas metodologías. &amp;#8220;&lt;em&gt;Seguro que aprendo de ambas partes&lt;/em&gt;&amp;#8220;, pensaba yo.&lt;/p&gt;

&lt;p&gt;Ingenuo de mí.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Tres &lt;em&gt;hangouts&lt;/em&gt; despues, la idea general que para mí resume el debate es que DHH dice que TDD puede desencadenar en mal código. El problema fundamental que tiene su argumento es que esto no es exclusivo de TDD. Hacer TDD te puede llevar a un mal código de la misma manera que utilizar mal cualquier otra herramienta podría llevarnos por el mal camino.&lt;/p&gt;

&lt;h2 id=&#34;tests-como-herramientas-de-diseño&#34;&gt;Tests como herramientas de diseño&lt;/h2&gt;

&lt;p&gt;A veces parece que lo que no le gusta de TDD y de los tests unitarios, es que a diferencia de los tests de sistema que él prefiere, los unitarios son tests que no te ocultan los problemas que tiene tu código. &lt;strong&gt;No puedes crear un tests en aislamiento cuando tu clase tiene mil dependencias y no cumples cosas como la ley de Demeter o los principios SOLID&lt;/strong&gt;. Sin embargo, los tests de sistema no se quejarán en absoluto. No son nada exigentes en ese sentido. A cambio, ¿qué pierdes? Pierdes feedback instantáneo sobre cómo de bien (o mal) estás diseñando algo. Pierdes velocidad en los tests que pasan de segundos a minutos.&lt;/p&gt;

&lt;p&gt;Eligiendo el camino de los tests de sistema puede dar la impresión de que vamos más rápido porque tenemos que pensar menos los tests, pero lo que realmente estamos haciendo es &lt;strong&gt;esconder el polvo debajo de la alfombra&lt;/strong&gt;. El problema es que llegará un día que la alfombra no será suficiente, y cuando nos queramos dar cuenta, &lt;strong&gt;las termitas han tomado el lugar&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;arquitectura-hexagonal&#34;&gt;Arquitectura Hexagonal&lt;/h2&gt;

&lt;p&gt;Otro argumento que me chocó de DHH, que menciona en el segundo &lt;em&gt;hangout&lt;/em&gt;, es ese que dice que TDD penaliza el diseño porque tiendes a cosas como la arquitectura hexagonal. Para empezar, no entiendo qué relación tiene una cosa con la otra. Puedes hacer una arquitectura hexagonal sin hacer TDD y viceversa.&lt;/p&gt;

&lt;p&gt;Además, dice que elegimos utilizar arquitectura hexagonal porque nos ayuda a crear tests. Que el principal motivo de este tipo de arquitectura es el testing.&lt;/p&gt;

&lt;p&gt;En &lt;a title=&#34;Arquitectura Hexagonal&#34; href=&#34;https://www.youtube.com/watch?v=vX5PBaXopmg&#34; target=&#34;_blank&#34;&gt;mi charla sobre arquitectura hexagonal&lt;/a&gt; (&lt;a title=&#34;Arquitectura Hexagonal&#34; href=&#34;https://speakerdeck.com/fiunchinho/hexagonal-architecture&#34; target=&#34;_blank&#34;&gt;slides&lt;/a&gt;), no se mencionan los tests hasta la slide número 55 (son 60). Y lo que digo es que la facilidad de hacer tests con este tipo de arquitecturas, es un buenísimo efecto secundario que tendremos. Pero nunca se vende que sea el principal motivo. Cierto es que en &lt;a title=&#34;Hexagonal Architecture&#34; href=&#34;http://alistair.cockburn.us/Hexagonal+architecture&#34; target=&#34;_blank&#34;&gt;el artículo original&lt;/a&gt; se hace más hincapié en los tests, pero para mí la principal ventaja es &lt;strong&gt;la independencia de herramientas&lt;/strong&gt;: frameworks, bases de datos, etc,. además de promocionar al dominio a un sitio más visible y acorde a la importancia que tiene.&lt;/p&gt;

&lt;h2 id=&#34;conclusión&#34;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Me veré el último hangout, porque siempre se puede aprender algo de estas tres fieras, pero para mi, el debate no se ha llevado en ningún momento por cauces interesantes. Prefiero no pensarlo, pero ya van varias personas que mencionan que DHH solo pretendía hacer ruido. Espero que no fuese así.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>El problema con el code coverage</title>
      <link>https://fiunchinho.github.io/blog/el-problema-con-el-code-coverage/</link>
      <pubDate>Thu, 01 May 2014 13:27:28 +0000</pubDate>
      
      <guid>https://fiunchinho.github.io/blog/el-problema-con-el-code-coverage/</guid>
      <description>&lt;p&gt;Me he permitido el lujo de &lt;a title=&#34;Considered harmful&#34; href=&#34;http://en.wikipedia.org/wiki/Considered_harmful&#34; target=&#34;_blank&#34;&gt;parafrasear a los maestros&lt;/a&gt; en el título de este artículo para hablaros de un tema algo polémico, por lo menos en los círculos en los que lo he hablado. Se trata de la necesidad de una alta cobertura de código, o &lt;em&gt;code coverage&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El tema me lo recordó una serie de tweets que intercambiamos el otro día algunos en Twitter, hablando sobre la importancia de tener una cobertura de código del 100%. En el fondo todos estábamos de acuerdo en que no es importante tener un 100%, aunque no es la opinión más habitual que leerás por internet o escucharás en empresas. Mi opinión es que exigir cierto porcentaje de cobertura de código no es que no aporte nada, &lt;strong&gt;sino que es algo perjudicial&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; width=&#34;550&#34;&gt;
  &lt;p&gt;
    .&lt;a href=&#34;https://twitter.com/SergiGP&#34;&gt;@SergiGP&lt;/a&gt; &lt;a href=&#34;https://twitter.com/theUniC&#34;&gt;@theUniC&lt;/a&gt; Tener un porcentaje alto de code coverage es una consecuencia, no un objetivo. No hay que olvidarlo nunca.
  &lt;/p&gt;
  
  &lt;p&gt;
    &amp;mdash; Jose Armesto (@fiunchinho) &lt;a href=&#34;https://twitter.com/fiunchinho/statuses/459038699079344128&#34;&gt;April 23, 2014&lt;/a&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;qué-es-la-cobertura-de-código&#34;&gt;¿Qué es la cobertura de código?&lt;/h2&gt;

&lt;p&gt;La cobertura de código es una métrica que nos dice qué líneas de nuestro código ha sido ejecutado tras lanzar un test. De esta forma, yo puedo saber si hay partes de mi código que no están siendo testeadas. Este porcentaje se utiliza para medir la salud de un proyecto ya que si tiene un porcentaje bajo, podemos afirmar que hay muchas partes del código de las que no podemos estar seguros de si funcionan o no.&lt;/p&gt;

&lt;p&gt;Una vez que sabemos qué es, la siguiente pregunta sale de forma natural.&lt;/p&gt;

&lt;h2 id=&#34;cuanta-cobertura-de-código-es-necesaria&#34;&gt;¿Cuanta cobertura de código es &lt;em&gt;necesaria&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;Nótese el énfasis en la palabra &amp;#8220;necesaria&amp;#8221;. Y aquí es donde viene el problema. Muchos dirán que es una locura subir un código a producción que no llegue al 80% de cobertura. Otros te dirán incluso que 90%. Y siempre encontrarás al fanático que no programa ni el vídeo VHS y que dice que él no sube a producción nada que baje del 100%, porque es el porcentaje que obtiene al hacer siempre TDD.&lt;/p&gt;

&lt;p&gt;Mi problema con todo esto es que los tests son una &lt;strong&gt;herramienta de confianza&lt;/strong&gt;. Además de que me ayudan a &lt;a title=&#34;Yo no soy DHH. Long live TDD&#34; href=&#34;http://blog.armesto.net/yo-no-soy-dhh-long-live-tdd/&#34; target=&#34;_blank&#34;&gt;conseguir un mejor diseño haciéndome pensar en el problema antes de pensar en la solución&lt;/a&gt;, me ayudan a detectar errores ejecutándolos después de cada refactorización. Esto hace que yo tenga toda la seguridad del mundo en refactorizar código: sé que siempre puedo lanzar los tests y ver si he roto algo. Es mi red de seguridad, mi chivato de errores. Entonces, ¿cuantos tests tengo que escribir? La respuesta es obvia: &lt;strong&gt;los tests necesarios para conseguir esa confianza&lt;/strong&gt;. Los necesarios para decir, si están en verde es que todo está bien.&lt;/p&gt;

&lt;p&gt;¿Cómo se mide esa confianza en un porcentaje de code coverage equivalente? &lt;strong&gt;No se puede&lt;/strong&gt;. No se puede porque depende del código que estés haciendo. Si esa clase tiene un &lt;em&gt;getter&lt;/em&gt; que lo único que hace es devolver una propiedad y nada más, no escribiré un test para ese método. Si ese otro método es complejo y posiblemente cambiará, créeme que lo testearé concienzudamente. La mejor metáfora que he visto sobre esto es la publicada en 2007, respondiendo a esta misma pregunta &lt;a title=&#34;How much code coverage do you need?&#34; href=&#34;http://www.developertesting.com/archives/month200705/20070504-000425.html&#34; target=&#34;_blank&#34;&gt;How much test coverage do you need?&lt;/a&gt;:&lt;/p&gt;

&lt;div style=&#34;border-left: 5px solid #edece4&#34;&gt;
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;Early one morning, a programmer asked the great master:&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“I am ready to write some unit tests. What code coverage should I aim for?”&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;The great master replied:&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“Don’t worry about coverage, just write some good tests.”&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;The programmer smiled, bowed, and left.&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;&amp;#8230;&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;Later that day, a second programmer asked the same question.&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;The great master pointed at a pot of boiling water and said:&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“How many grains of rice should put in that pot?”&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;The programmer, looking puzzled, replied:&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“How can I possibly tell you? It depends on how many people you need to feed, how hungry they are, what other food you are serving, how much rice you have available, and so on.”&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“Exactly,” said the great master.&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;The second programmer smiled, bowed, and left.&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;&amp;#8230;&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;Toward the end of the day, a third programmer came and asked the same question about code coverage.&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“Eighty percent and no less!” Replied the master in a stern voice, pounding his fist on the table.&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;The third programmer smiled, bowed, and left.&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;&amp;#8230;&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;After this last reply, a young apprentice approached the great master:&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“Great master, today I overheard you answer the same question about code coverage with three different answers. Why?”&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;The great master stood up from his chair:&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“Come get some fresh tea with me and let’s talk about it.”&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;After they filled their cups with smoking hot green tea, the great master began to answer:&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“The first programmer is new and just getting started with testing. Right now he has a lot of code and no tests. He has a long way to go; focusing on code coverage at this time would be depressing and quite useless. He’s better off just getting used to writing and running some tests. He can worry about coverage later.”&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“The second programmer, on the other hand, is quite experience both at programming and testing. When I replied by asking her how many grains of rice I should put in a pot, I helped her realize that the amount of testing necessary depends on a number of factors, and she knows those factors better than I do – it’s her code after all. There is no single, simple, answer, and she’s smart enough to handle the truth and work with that.”&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“I see,” said the young apprentice, “but if there is no single simple answer, then why did you answer the third programmer ‘Eighty percent and no less’?”&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;The great master laughed so hard and loud that his belly, evidence that he drank more than just green tea, flopped up and down.&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;“The third programmer wants only simple answers – even when there are no simple answers … and then does not follow them anyway.”&lt;/em&gt;
  &lt;/p&gt;
  
  &lt;p style=&#34;padding-left: 30px;&#34;&gt;
    &lt;em&gt;The young apprentice and the grizzled great master finished drinking their tea in contemplative silence.&lt;/em&gt;
  &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;problemática&#34;&gt;Problemática&lt;/h2&gt;

&lt;p&gt;El problema de exigir un code coverage mínimo a los programadores, de proveer una respuesta simple a la pregunta, hace que el foco de los tests se centre en llegar a ese número mágico que nos hemos sacado de la manga, cuando el foco debería estar orientado a pensar qué tests son realmente importantes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Una cobertura baja nos indica si un código está mal testeado, pero una alta no nos dice que un código esté bien testeado. De la misma forma que un test en rojo nos dice que hay un error, pero uno en verde no nos asegura la ausencia de errores.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;La motivación para exigir un code coverage mínimo creo que sale de &lt;a title=&#34;Ni hombres lobo ni balas de plata&#34; href=&#34;http://blog.armesto.net/ni-hombres-lobo-ni-balas-de-plata/&#34; target=&#34;_blank&#34;&gt;la necesidad de buscar respuesta a preguntas complejas&lt;/a&gt; del desarrollo de software. Centrándonos en llegar al mínimo de cobertura de código, puede hacer que un comportamiento del programa se nos escape e introduzcamos un bug en el sistema, porque estábamos demasiado ocupados escribiendo tests sin valor para pasar por las líneas que nos exigían.&lt;/p&gt;

&lt;h2 id=&#34;conclusión&#34;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Escribir tests es lo mejor que puedes hacer, y soy un gran defensor de utilizar TDD, pero como dijo Kent Beck en su &lt;a title=&#34;Kent Beck on code coverage&#34; href=&#34;http://stackoverflow.com/a/153565/563072&#34; target=&#34;_blank&#34;&gt;famosísima respuesta de Stack Overflow&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Me pagan por escribir código que funciona, no tests.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tener una alta de cobertura no es un objetivo a tener, sino que es una consecuencia de haber pensado bien en el problema que estamos solventando y en los comportamientos que son interesantes para testear. Los que no lo sean, no tenemos por qué testearlos.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Yo no soy DHH. Long live TDD</title>
      <link>https://fiunchinho.github.io/blog/yo-no-soy-dhh-long-live-tdd/</link>
      <pubDate>Thu, 24 Apr 2014 00:35:31 +0000</pubDate>
      
      <guid>https://fiunchinho.github.io/blog/yo-no-soy-dhh-long-live-tdd/</guid>
      <description>&lt;p&gt;DHH es un gran programador, creador de algo como &lt;a title=&#34;Rails&#34; href=&#34;http://rubyonrails.org/&#34; target=&#34;_blank&#34;&gt;Rails&lt;/a&gt;, framework que quedará en la historia de la programación web. Hoy, él, ha sido noticia por escribir &lt;a title=&#34;TDD is dead&#34; href=&#34;http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html&#34; target=&#34;_blank&#34;&gt;un post titulado &amp;#8220;TDD is dead&amp;#8221;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Quizá DHH está en lo cierto diciendo que TDD es algo que está muerto, que es momento de seguir hacia adelante y dejarlo atrás. Como cuando crecemos y dejamos de utilizar los &lt;a title=&#34;ruedines de bici&#34; href=&#34;http://1.bp.blogspot.com/_95Yb4E_y8Cs/S_HClbzs9YI/AAAAAAAADVs/iiwdG-vqq3Y/s1600/orbea-bicicleta-kids-atlantis-14.jpg&#34; target=&#34;_blank&#34;&gt;ruedines de la bicicleta&lt;/a&gt;: es algo para niños pequeños, pero de mayores ya no nos hacen falta. Quizá tiene razón.&lt;/p&gt;

&lt;p&gt;Si eres lo suficientemente experto, entonces quizá ya no tiene sentido. Porque para mí TDD es eso: unos ruedines para programar que me ayudan a conseguir un mejor código. Si fuese capaz de escribir el mejor código posible a la primera, que siguiese los principios SOLID, que fuese auto explicativo, etc., entonces yo tampoco haría TDD.  &lt;strong&gt;¿Para qué molestarme?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Si me saliese a la primera, no necesitaría refactorizar muy frecuentemente y tener un unit testing que me avise cuando he roto algo. No me haría falta ese loop de feedback tan corto.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;no-todos-somos-dhh&#34;&gt;No todos somos DHH&lt;/h2&gt;

&lt;p&gt;El problema es que poca gente tiene la capacidad de hacerlo así de bien siempre. Sobre todo porque normalmente programamos cosas que nunca antes hemos programado. Si estoy haciendo algo que ya hice con anterioridad, quizá no es tan importante seguir un TDD estricto. Ahí tomaré atajos.&lt;/p&gt;

&lt;p&gt;Pero si lo que estoy haciendo es completamente nuevo y no sé por donde atacarlo, créeme que haré TDD sin dudarlo, &lt;strong&gt;siguiendo todos y cada uno de los pasos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Como la mayoría de la gente no tiene esa capacidad que decía antes, la metedura de pata del post de DHH me parece mayúscula. Me lo parece porque no solo dice que TDD no es para él, sino que anima a la gente a no utilizarlo, y deja entrever que hará cambios en rails para animar a la gente a hacer menos unit testings y más tests de otro tipo.&lt;/p&gt;

&lt;p&gt;Teniendo en cuenta su posición de lider en la comunidad, me parece una temeridad por su parte. Está invitando a la gente a que rompa algo tan establecido y aprobado como la &lt;a title=&#34;Testing Pyramid&#34; href=&#34;http://martinfowler.com/bliki/TestPyramid.html&#34; target=&#34;_blank&#34;&gt;pirámide de testing&lt;/a&gt;, basándose en que no han sido tests útiles para testear aplicaciones basadas en rails. Un vistazo rápido a las charlas de las conferencias de Ruby de los últimos años y vemos como hay un tema recurrente en todas ellas: &lt;a title=&#34;Deconstructing the framework&#34; href=&#34;https://www.youtube.com/watch?v=iUe6tacW3JE&#34; target=&#34;_blank&#34;&gt;cómo escapar de Rails&lt;/a&gt;. Bien sea por hacer &lt;a title=&#34;Fast tests&#34; href=&#34;https://www.youtube.com/watch?v=bNn6M2vqxHE&#34; target=&#34;_blank&#34;&gt;tests más rápidos&lt;/a&gt; y tener feedback antes; o porque los modelos de mi aplicación no &lt;a title=&#34;ActiveRecord&#34; href=&#34;https://www.youtube.com/watch?v=yuh9COzp5vo&#34; target=&#34;_blank&#34;&gt;estén entre mezclados con el sistema de persistencia&lt;/a&gt;; o porque quiero tener a&lt;a title=&#34;Hexagonal Rails&#34; href=&#34;https://www.youtube.com/watch?v=CGN4RFkhH2M&#34; target=&#34;_blank&#34;&gt;rquitecturas que me permitan intercambiar componentes fácilmente&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Siempre lo que se busca es escapar de Rails, minimizar la dependencia con el framework. Los unit testings son costosos de hacer cuando el framework está en el medio. Por eso no le han sido útiles: porque su framework no permitía que lo fuesen. La solución, obviamente, no es dejar de hacerlos, sino arreglar el framework.&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; width=&#34;550&#34;&gt;
  &lt;p&gt;
    Sit-ups are dead. They don’t work when I eat all this sugar and take on all this severe stress. Long live gastric bypass surgery.
  &lt;/p&gt;
  
  &lt;p&gt;
    &amp;mdash; ☕ J. B. Rainsberger (@jbrains) &lt;a href=&#34;https://twitter.com/jbrains/statuses/458983164502093824&#34;&gt;April 23, 2014&lt;/a&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;el-dogma&#34;&gt;El Dogma&lt;/h2&gt;

&lt;p&gt;De todas formas sí que comparto con él una cosa, y es el nivel de dogma que TDD ha alcanzado en los últimos años. Personas como Uncle Bob, cuando hablan de TDD, se ponen una sotana encima para predicar la palabra sagrada. Uncle Bob ha sido capaz de convertir la práctica de TDD en una religión.&lt;/p&gt;

&lt;div style=&#34;width: 213px&#34; class=&#34;wp-caption alignleft&#34;&gt;
  &lt;img alt=&#34;Uncle Bob, el predicador&#34; src=&#34;http://blogs.msdn.com/blogfiles/cdndevs/WindowsLiveWriter/CraftsmanshipandEthicsUncleBobsKeynote_E0E9/uncle_bob_martin_3.jpg&#34; width=&#34;203&#34; height=&#34;214&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Uncle Bob, el predicador de Texas
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Es una religión porque al igual que las religiones, el TDD de Uncle Bob promete la salvación eterna si cumples con los mandamientos (&lt;a title=&#34;3 rules of TDD&#34; href=&#34;http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd&#34; target=&#34;_blank&#34;&gt;3 en el caso del TDD&lt;/a&gt;). Pero no solo eso, sino que también asegura el castigo eterno para aquellos que no lo hagan. Eso es lo que hace cuando alude al poco profesionalismo de la gente que no lo practica. Está señalando a los herejes.&lt;/p&gt;

&lt;p&gt;En mi opinión, &lt;strong&gt;hacer TDD es una herramienta más&lt;/strong&gt;. Una herramienta casi imprescindible para mi, pero una herramienta al fin y al cabo. A alguien que utilizase el bloc de notas para programar le recomendaría que probase Sublime o PHPStorm. Al igual que le recomendaría TDD si no lo utiliza. En ambos casos creo que esa persona será más productiva y hará mejor código. Por tanto será un programador más rentable. ¿Quiere decir esto que no se puede ser rentable si no se usa TDD? Claro que no, al igual que también puedes ser un crack en el bloc de notas.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Los defensores de TDD también debemos hacer auto-crítica y pensar en si la forma que elegimos para comunicar las bondades de TDD es la más correcta.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;conclusión&#34;&gt;&lt;strong&gt;Conclusión&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Para mi su post de hoy ha sido una gran metedura de pata. Los unit testings aportan muchísimo valor a la hora de detectar errores, y el TDD es una de las mejores herramientas para que nuestro diseño sea mejor.&lt;/p&gt;

&lt;p&gt;Yo no soy DHH. No he inventado Rails ni soy el CTO de &lt;a title=&#34;Basecamp&#34; href=&#34;https://basecamp.com/&#34; target=&#34;_blank&#34;&gt;una gran compañía&lt;/a&gt;. Yo seguiré utilizando TDD para que me ayude a hacer el mejor código posible.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sácale todo el partido a los tests haciendo que griten</title>
      <link>https://fiunchinho.github.io/blog/sacale-todo-el-partido-a-los-tests-haciendo-que-griten/</link>
      <pubDate>Sun, 26 Jan 2014 18:09:33 +0000</pubDate>
      
      <guid>https://fiunchinho.github.io/blog/sacale-todo-el-partido-a-los-tests-haciendo-que-griten/</guid>
      <description>&lt;p&gt;Si tuviese que decir en qué se basa una prueba unitaria, diría que las principales características que debe cumplir son (sin ningún orden en particular):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Que sea rápido y sin efectos secundarios.&lt;/li&gt;
&lt;li&gt;Que sea realmente unitario.&lt;/li&gt;
&lt;li&gt;Que sea auto explicativo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pero con el tiempo veo que la gente tiende a &lt;strong&gt;centrarse en las dos primeras de mi lista&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Se busca que sea rápido y sin efectos secundarios porque de esa forma podemos lanzarlos siempre que queramos, dándonos confianza. Si tuviésemos que esperar minutos en saber el resultado, o tuviésemos que andar limpiando una base de datos cada vez que quisiésemos lanzar pruebas, simplemente no lo haríamos tan frecuentemente como debiéramos.&lt;/p&gt;

&lt;p&gt;También se prioriza que sean unitarios y aislados, para que cuando algo falle, tengamos la granularidad suficiente para identificar el problema en cuestión de segundos. Si tuviésemos una prueba que lo probase todo, el día que fallase, no sabríamos cual de las partes ha sido la culpable.&lt;/p&gt;

&lt;p&gt;Y aunque considero que estas dos características son importantísimas, &lt;strong&gt;creo que se desprecia la última de mi lista&lt;/strong&gt;. Las pruebas deberían ser auto explicativas, en el sentido de que debería ser muy fácil saber qué se está probando en todo momento, y sobretodo, qué hace el componente que estamos probando.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;La mayoría del tiempo que programamos nos la pasamos leyendo código ya existente, intentando entender qué es lo que hace. Esto implica tener que leer las pruebas. Y no sé vosotros, pero yo me he encontrado con tests infumables.&lt;/p&gt;

&lt;h2 id=&#34;como-mejorar-la-legibilidad-de-los-tests&#34;&gt;Como mejorar la legibilidad de los tests&lt;/h2&gt;

&lt;p&gt;Voy a poner un ejemplo muy sencillo donde podemos aplicar una serie de mejoras. Quizá al ser tan simple se vea menos el efecto, pero aplicándolo a esos mastodontes que nos podemos encontrar en la vida real, creedme que mejoraremos mucho los tests.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;El refactoring de extraer método no sirve para ahorrar líneas de código, si no para que el método sea más fácil de leer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;primera-aproximación-mocks-en-métodos-privados&#34;&gt;Primera aproximación: mocks en métodos privados&lt;/h3&gt;

&lt;p&gt;En el siguiente ejemplo, tenemos una clase encargada de identificar usuarios. Tiene dos colaboradores: el repositorio de usuarios para encontrar usuarios, y un codificador de contraseñas.&lt;/p&gt;

&lt;pre&gt;&lt;code data-lang=&#34;php&#34;&gt;public function testShouldReturnAuthenticatedUserForValidCredentials()
{
    $email      = &#39;john@doe.com&#39;;
    $encoded_pass   = &#39;encoded_pass&#39;;
    $password           = &#39;decoded_pass&#39;;
    $user       = new User( $email, $encoded_pass );
    $user_repo  = $this-&amp;gt;getMock( &#39;UserRepository&#39; );
    $user_repo
    -&amp;gt;expect( $this-&amp;gt;any() )
    -&amp;gt;method( &#39;findByEmail&#39; )
    -&amp;gt;will( $this-&amp;gt;returnValue( $user ) );

    $pass_encoder   = $this-&amp;gt;getMock( &#39;PasswordEncoder&#39; );
    $pass_encoder
    -&amp;gt;expect( $this-&amp;gt;once() )
        -&amp;gt;method( &#39;hash&#39; )
    -&amp;gt;with( $password )
    -&amp;gt;will( $this-&amp;gt;returnValue( $encoded_pass ) );

    $auth_service   = new AuthService( $user_repo, $pass_encoder );

    $this-&amp;gt;assertEquals(
    $user,
    $auth_service-&amp;gt;authenticate( $email, $password ),
    &#39;Must return the user when credentials are valid.&#39;
    );
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A pesar de que apenas hay lógica que testear, y gracias en parte a lo incómodo de PHPUnit (tenéis que probar &lt;a title=&#34;PHPSpec&#34; href=&#34;http://www.phpspec.net/&#34; target=&#34;_blank&#34;&gt;PHPSpec&lt;/a&gt;, en serio), los tests empiezan a crecer, &lt;strong&gt;obligándonos a leer un montón de líneas cada vez que queramos entender qué hace esto&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Muchos programadores intentan solventar este problema extrayendo un método para, por ejemplo, la creación de mocks. Queda algo tal que así.&lt;/p&gt;

&lt;pre&gt;&lt;code data-lang=&#34;php&#34;&gt;public function testShouldReturnAuthenticatedUserForValidCredentials()
{
    $email      = &#39;john@doe.com&#39;;
    $encoded_pass   = &#39;encoded_pass&#39;;
    $password   = &#39;decoded_pass&#39;;
    $user       = new User( $email, $encoded_pass );

    $this-&amp;gt;createRepositoryMock( $email, $encoded_pass );
    $this-&amp;gt;createEncoderMock( $password, $encoded_pass );

    $auth_service   = new AuthService( $user_repo, $pass_encoder );

    $this-&amp;gt;assertEquals(
    $user,
    $auth_service-&amp;gt;authenticate( $email, $password ),
    &#39;Must return the user when credentials are valid.&#39;
    );
}

private function createRepositoryMock( $email, $password )
{
    $user       = new User( $email, $password );
    $user_repo  = $this-&amp;gt;getMock( &#39;UserRepository&#39; );
    $user_repo
    -&amp;gt;expect( $this-&amp;gt;any() )
    -&amp;gt;method( &#39;findByEmail&#39; )
    -&amp;gt;will( $this-&amp;gt;returnValue( $user ) );

    return $user_repo;
}

private function createEncoderMock( $password, $encoded_pass )
{
    $pass_encoder   = $this-&amp;gt;getMock( &#39;PasswordEncoder&#39; );
    $pass_encoder
    -&amp;gt;expect( $this-&amp;gt;once() )
    -&amp;gt;method( &#39;hash&#39; )
    -&amp;gt;with( $password )
    -&amp;gt;will( $this-&amp;gt;returnValue( $encoded_pass ) );

    return $pass_encoder;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aunque a priori pueda parecer que esto ha mejorado la legibilidad de nuestros tests, nada más lejos de la realidad. Lo único que hemos hecho es reducir el número de líneas del test, pero sigo teniendo que leerme todo cada vez que necesite entenderlo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;El refactoring de extraer método no sirve para ahorrar líneas, si no para que el método sea más fácil de leer.&lt;/strong&gt; El nombre _createRepositoryMock()_ no me dice absolutamente nada sobre por qué lo estamos haciendo.&lt;/p&gt;

&lt;h3 id=&#34;un-enfoque-mejor&#34;&gt;Un enfoque mejor&lt;/h3&gt;

&lt;p&gt;Si el objetivo es que se entienda mejor el código, ¿por qué no hace todo explícito? Vamos a hacer lo mismo, pero pensando en el por qué de las cosas.&lt;/p&gt;

&lt;pre&gt;&lt;code data-lang=&#34;php&#34;&gt;public function testShouldReturnAuthenticatedUserForValidCredentials()
{
    $email      = &#39;john@doe.com&#39;;
    $encoded_pass   = &#39;encoded_pass&#39;;
    $password   = &#39;decoded_pass&#39;;
    $user       = $this-&amp;gt;createExistingUser( $email, $encoded_password );
    $user_repo  = $this-&amp;gt;createUserRepoWhenUserExists( $user );
    $pass_encoder   = $this-&amp;gt;createEncoderWhenEncoderMustEncodePassword( $password, $encoded_pass );

    $auth_service   = new AuthService( $user_repo, $pass_encoder );

    $this-&amp;gt;assertEquals(
    $user,
    $auth_service-&amp;gt;authenticate( $email, $password ),
    &#39;Must return the valid user when credentials are valid.&#39;
    );
}

private function createUserRepoWhenUserExists( $user )
{
    $user_repo = $this-&amp;gt;getMock( &#39;UserRepository&#39; );
    $user_repo
    -&amp;gt;expect( $this-&amp;gt;any() )
    -&amp;gt;method( &#39;findByEmail&#39; )
    -&amp;gt;will( $this-&amp;gt;returnValue( $user ) );

    return $user_repo;
}

private function createExistingUser( $email, $password )
{
    return new User( $email, $password );
}

private function createEncoderWhenEncoderMustEncodePassword( $password, $encoded_pass )
{
    $pass_encoder = $this-&amp;gt;getMock( &#39;PasswordEncoder&#39; );
    $pass_encoder
    -&amp;gt;expect( $this-&amp;gt;once() )
    -&amp;gt;method( &#39;hash&#39; )
    -&amp;gt;with( $password )
    -&amp;gt;will( $this-&amp;gt;returnValue( $encoded_pass ) );

    return $pass_encoder;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Estos nombres no tienen por qué ser los mejores, pero la idea es esa: hacer explícito el motivo de todo, para que cuando volvamos a leer el código (o algún compañero nuestro), todo lo que está ocurriendo se entienda a la perfección.&lt;/p&gt;

&lt;p&gt;Este primer enfoque es bastante básico, y si vemos que se complica, siempre podemos acudir a patrones de creación como el patrón builder o factories para los mocks.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Revelar la intención de nuestro código y el objetivo del test: lo más importante&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Haciendo que el objetivo de cada línea sea revelar con claridad la intención de nuestro código y qué caso concreto estamos testeando en ese momento, reduciremos muchísimo el tiempo necesario para entenderlo. &lt;strong&gt;Da igual que ocupe más líneas, o que tarde dos microsegundos más en ejecutarse&lt;/strong&gt;. Los objetivos de los tests son los que vimos al principio de este artículo, no son el rendimiento o tener menos líneas de código.&lt;/p&gt;

&lt;h2 id=&#34;luchando-contra-la-duplicación&#34;&gt;Luchando contra la duplicación&lt;/h2&gt;

&lt;p&gt;He visto desarrolladores que detectan que necesitarán un stub en todos los test cases, así que sacan la creación del stub al método de setUp, para ahorrar las líneas de configuración del stub.&lt;/p&gt;

&lt;p&gt;Volvemos a lo mismo. Debemos preguntarnos si eso mejora la legibilidad del test. En mi opinión, normalmente no lo hace, porque _esconde_ una colaboración, que puede que pasemos por alto ya que está en el setUp y no en el test case.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Pero entonces tendremos duplicación!”&lt;/em&gt;, me dirán los lectores más atentos. Pero yo no digo que dupliquemos, sino que lo hagamos explícito. Si vemos que por hacerlo explícito vamos a duplicar código, saquemos la duplicación a un método privado que contenga la lógica que se duplica, y llamemos a este método privado desde el test case. El nombre de ese método privado nos dirá el motivo de por qué está ese código ahí.&lt;/p&gt;

&lt;h2 id=&#34;conclusión&#34;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Nunca debemos olvidar que &lt;strong&gt;los tests son nuestra primera documentación&lt;/strong&gt;. Es la mejor forma de ver cómo funciona un componente, cómo se configura, y qué valores debo esperar que devuelva. Cuando tengo que modificar código ya existente, entender qué es lo que hace es vital. Si no hago que mis tests &lt;strong&gt;GRITEN&lt;/strong&gt; el comportamiento de mis clases, me estoy perdiendo otra de las grandes ventajas de los tests.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Inspección continua de la calidad de nuestro código</title>
      <link>https://fiunchinho.github.io/blog/inspeccion-continua-de-la-calidad-de-nuestro-codigo/</link>
      <pubDate>Tue, 05 Nov 2013 18:05:53 +0000</pubDate>
      
      <guid>https://fiunchinho.github.io/blog/inspeccion-continua-de-la-calidad-de-nuestro-codigo/</guid>
      <description>&lt;p&gt;Una de las formas que tenemos para poder mejorar el código de nuestro proyecto es someterlo a una inspección continua y constante. Lo primero que podemos hacer es lanzar nuestros tests tras cada push al repositorio, de forma que sabremos en todo momento si hay algo que no funciona bien.&lt;/p&gt;

&lt;p&gt;También podemos analizar la complejidad del código y comprobar si estamos incrementándola o disminuyéndola.&lt;/p&gt;

&lt;p&gt;Hasta ahora, todas estas tareas eran posibles solamente teniendo un servidor de integración continua configurado, siendo Jenkins el más famoso. En él podemos ejecutar todas estas tareas tras cada push. Recursos como &lt;a href=&#34;http://jenkins-php.org/&#34;&gt;http://jenkins-php.org/&lt;/a&gt; te ayudarán a configurar este versátil servidor hecho en Java.&lt;/p&gt;

&lt;p&gt;La buena noticia es que cada vez hay más herramientas online que te permiten hacer estas tareas sin necesidad de configurar practicamente nada. Hoy veremos como lanzar tests y analizar la calidad de nuestro código sin utilizar un servidor de integración continua.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;ejecutando-nuestros-tests&#34;&gt;Ejecutando nuestros tests&lt;/h2&gt;

&lt;p&gt;Estos dos últimos años han sido la explosión en popularidad de &lt;a title=&#34;TravisCI&#34; href=&#34;https://travis-ci.org/&#34; target=&#34;_blank&#34;&gt;TravisCI&lt;/a&gt;. TravisCI es un servicio que te permitirá lanzar tu suite de tests tras cada push. ¿Cómo? Pues cada vez que se envía código al repositorio, TravisCI levantará una máquina virtual y clonará tu código en ella. Una vez todo esté allí, &lt;strong&gt;ejecutará los tests y te dirá si algo se ha roto&lt;/strong&gt; o todo sigue correcto.&lt;/p&gt;

&lt;p&gt;También te permite ejecutar comandos antes de lanzar los tests, por si necesitas instalar dependencias de otras librerías o incluso programas en la máquina virtual.&lt;/p&gt;

&lt;p&gt;Para que todo esto funcione, necesitas tener un archivo de configuración en tu repositorio que le diga a TravisCI qué es lo que tiene que hacer. Este archivo se llama _.travis.yml_ y un ejemplo podría ser este&lt;/p&gt;

&lt;pre&gt;&lt;code data-lang=&#34;yaml&#34;&gt;language: php
php:
    - 5.3
    - 5.4
    - 5.5
before_install:
    - curl -s http://getcomposer.org/installer | php
    - php composer.phar --dev install&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con esta configuración le estamos diciendo a TravisCI que nuestro lenguaje es PHP, que queremos que lance los tests en 3 máquinas virtuales distintas, una con la versión 5.3 de PHP, otra con la 5.4 y otra con la 5.5. Además, antes de poder lanzar los tests, le decimos que instale las dependencias de nuestro proyecto mediante composer.&lt;/p&gt;

&lt;p&gt;El hecho de saber si algo se ha roto con un commit es de vital importancia, sobretodo en proyectos con muchos programadores distintos, como los proyectos Open Source. Para esto, cada vez que hay un cambio de estado (alguien rompe los tests y pasamos de estable a roto, o viceversa), TravisCI nos enviará un email para tenernos informados.&lt;/p&gt;

&lt;p&gt;Para que todo el mundo tenga visibilidad del estado actual, también pone a nuestra disposición una insignia que indica si los tests están en rojo o en verde. Podemos colocar esta insignia en el README.md de nuestro proyecto, y cualquiera que entre verá si hay algo roto.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_025.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-55&#34; alt=&#34;PHPUnit badge&#34; src=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_025.png&#34; width=&#34;801&#34; height=&#34;112&#34; srcset=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_025.png 801w, http://blog.armesto.net/wp-content/uploads/2014/04/Selección_025-300x41.png 300w&#34; sizes=&#34;(max-width: 801px) 100vw, 801px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Por último, recuerda que por defecto TravisCI ejecutará &lt;strong&gt;PHPUnit&lt;/strong&gt; para lanzar los tests, utilizando la configuración del fichero _phpunit.xml.dist_ para saber donde están los tests y cómo lanzarlos. Si quieres cambiar algo de lo que TravisCI hace por defecto, &lt;a title=&#34;TravisCI Docs&#34; href=&#34;http://about.travis-ci.org/docs/user/languages/php/&#34; target=&#34;_blank&#34;&gt;la documentación&lt;/a&gt; está bastante bien.&lt;/p&gt;

&lt;h2 id=&#34;analizando-la-calidad-del-código&#34;&gt;Analizando la calidad del código&lt;/h2&gt;

&lt;p&gt;Existen &lt;a title=&#34;PHP QA Tools&#34; href=&#34;http://phpqatools.org/&#34; target=&#34;_blank&#34;&gt;un montón de herramientas de análisis estático de código PHP &lt;/a&gt;que nos dan todo tipo de información, desde si hay mucho copy/paste, hasta si nuestro código es poco abstracto. Son herramientas que puedes lanzar cuando quieras desde la consola, pero que como veíamos al principio del post, sería interesante lanzar cada vez que se envía código al repositorio. Si no queremos utilizar nuestro servidor de integración continua propio, una alternativa que tenemos es &lt;a title=&#34;Scrutinizer&#34; href=&#34;https://scrutinizer-ci.com/&#34; target=&#34;_blank&#34;&gt;Scrutinizer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Su funcionamiento es muy parecido al de TravisCI, pero en vez de lanzar tu suite de tests, lanzará todas las &lt;a title=&#34;Herramientas de análisis estático de código&#34; href=&#34;https://scrutinizer-ci.com/docs/tools/php/&#34; target=&#34;_blank&#34;&gt;herramientas de análisis estático de código&lt;/a&gt; que hayas configurado. Para la configuración, tan solo debes modificar en la web de Scrutinizer el archivo de configuración, o tener un archivo _.scrutinizer.yml_ en tu repositorio. En la web puedes elegir una configuración global para todos tus proyectos, o tener una distinta para cada uno.&lt;/p&gt;

&lt;p&gt;El mío tiene esta pinta&lt;/p&gt;

&lt;pre&gt;&lt;code data-lang=&#34;yaml&#34;&gt;filter:
 excluded_paths: [vendor/*, app/*, web/*]

tools:
 php_cpd: true
 php_pdepend:
     excluded_dirs: [vendor]
 php_mess_detector: true
 php_analyzer: true
 php_loc:
     command: phploc
     excluded_dirs: [vendor]
     enabled: true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No tengo seleccionadas todas las herramientas, pero para hacer una prueba es suficiente con estas.&lt;/p&gt;

&lt;p&gt;Una vez elegida tu configuración, puedes lanzar el análisis directamente eligiendo “_Schedule Inspection_” en la parte superior derecha. De todas formas, salvo que lo desactives en las opciones, cada vez que código nuevo se envíe al repositorio, se realizará una inspección de tu código.&lt;/p&gt;

&lt;h3 id=&#34;informes&#34;&gt;Informes&lt;/h3&gt;

&lt;p&gt;Lo bueno es que después de ejecutarse, Scrutinizer genera unos informes muy bonitos con todo tipo de información útil.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_023.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-56&#34; alt=&#34;Scrutinizer&#34; src=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_023-1024x651.png&#34; width=&#34;620&#34; height=&#34;394&#34; srcset=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_023-1024x651.png 1024w, http://blog.armesto.net/wp-content/uploads/2014/04/Selección_023-300x190.png 300w, http://blog.armesto.net/wp-content/uploads/2014/04/Selección_023.png 1099w&#34; sizes=&#34;(max-width: 620px) 100vw, 620px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Arriba de todo podemos ver &lt;strong&gt;la nota final de nuestro código&lt;/strong&gt;, 9.18 en la imagen. Esta nota es calculada teniendo en cuenta el resultado de todas las inspecciones que tenemos configuradas. También nos ofrece un histórico con nuestra nota, o los incidentes (issues) de nuestro código que todavía tenemos pendientes por arreglar.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_024.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-58&#34; alt=&#34;Scrutinizer&#34; src=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_024-1024x410.png&#34; width=&#34;620&#34; height=&#34;248&#34; srcset=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_024-1024x410.png 1024w, http://blog.armesto.net/wp-content/uploads/2014/04/Selección_024-300x120.png 300w, http://blog.armesto.net/wp-content/uploads/2014/04/Selección_024.png 1093w&#34; sizes=&#34;(max-width: 620px) 100vw, 620px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Por último, igual que TravisCI, nos ofrece la posibilidad de poner una insignia con nuestra nota en el README.md del repositorio, para que todo el mundo vea a simple vista la calidad del código.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_026.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-60&#34; alt=&#34;Scrutinizr badge&#34; src=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_026.png&#34; width=&#34;809&#34; height=&#34;236&#34; srcset=&#34;http://blog.armesto.net/wp-content/uploads/2014/04/Selección_026.png 809w, http://blog.armesto.net/wp-content/uploads/2014/04/Selección_026-300x87.png 300w&#34; sizes=&#34;(max-width: 809px) 100vw, 809px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;lo-tienes-fácil&#34;&gt;Lo tienes fácil&lt;/h2&gt;

&lt;p&gt;Antigüamente tenías que pelearte con un servidor tipo Jenkins si querías tener funcionalidades de integración continua, pero cada vez salen más herramientas online a la luz que nos ayudan con la calidad de nuestro código. Todavía no tenemos todo lo que un Jenkins nos puede ofrecer, pero con estos dos simples servicios que hemos visto hoy, ya tendríamos mucho ganado.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Detectando tests dependientes con PHPUnit</title>
      <link>https://fiunchinho.github.io/blog/detectando-tests-dependientes-con-phpunit/</link>
      <pubDate>Thu, 03 Oct 2013 18:07:55 +0000</pubDate>
      
      <guid>https://fiunchinho.github.io/blog/detectando-tests-dependientes-con-phpunit/</guid>
      <description>&lt;p&gt;A día de hoy, &lt;a title=&#34;PHPUnit&#34; href=&#34;https://github.com/sebastianbergmann/phpunit/&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt; es el standard _de facto_ para escribir pruebas unitarias en PHP. En estas pruebas unitarias, intentamos que los tests sean &lt;strong&gt;totalmente aislados&lt;/strong&gt;, es decir, que no tengan efectos secundarios, que no se conecten a servicios como API’s o bases de datos, y que no dependan unos de otros.&lt;/p&gt;

&lt;p&gt;Sin embargo, cuando estamos escribiendo tests de integración para comprobar que ciertas clases se comunican correctamente entre ellas, o con otros servicios (base de datos, API’s, etc), los tests dejan de ser aislados, porque esa conexión es precisamente lo que queremos probar. Además, puede que tengan efectos secundarios porque, siguiendo con el ejemplo de la base de datos, vamos a comprobar si se han escrito datos correctos o si se han actualizado como deberían.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Lo que sí vamos a querer mantener, salvo que realmente nos haga falta lo contrario, es que los tests &lt;strong&gt;no sean dependientes entre sí&lt;/strong&gt;. Es decir, que el orden en el que se ejecutan sea importante. No queremos que para que el &lt;code&gt;testB()&lt;/code&gt; pase en verde, deba ejecutarse siempre después del &lt;code&gt;testA()&lt;/code&gt;, y si esto no ocurre el test falle. Esto podría pasar por ejemplo cuando en el &lt;code&gt;testB()&lt;/code&gt; leemos de base de datos algo que estamos insertando en el &lt;code&gt;testA()&lt;/code&gt;. Si los cambiamos de orden, el &lt;code&gt;testB()&lt;/code&gt; no encontrará los registros, y el test fallará irremediablemente.&lt;/p&gt;

&lt;p&gt;Si conseguimos que los tests no compartan estados y que sean independientes, evitaremos que cuando alguien cambie el orden de los tests estos empiecen a fallar de forma aleatoria. En la vida real, sin embargo, estamos resolviendo problemas complejos y  podríamos meter la pata. El problema es que cuando la cantidad de código que tienes empieza a ser muy grande, se hace complicado saber si alguien ha metido la pata en algún test y lo ha hecho dependiente de otro.&lt;/p&gt;

&lt;p&gt;Para solucionar esto, &lt;a title=&#34;phpunit-randomizer&#34; href=&#34;https://github.com/fiunchinho/phpunit-randomizer&#34; target=&#34;_blank&#34;&gt;he creado una librería&lt;/a&gt; que podéis utilizar para lanzar los tests de PHPUnit de &lt;strong&gt;forma aleatoria&lt;/strong&gt;. Es decir, los test cases dentro de una clase de test se ejecutarán en un orden aleatorio, y si alguno dependía de la acción de otro, fallará y se pondrá de manifiesto que tiene que arreglarse.&lt;/p&gt;

&lt;p&gt;PHPUnit ya ofrece una opción para que cada test case se lance en un proceso de php independiente, llamada &lt;em&gt;process-isolation&lt;/em&gt;, pero esto provoca que los tests tarden mucho en ejecutarse, y cuando el número es elevado, el tiempo de espera se hace demasiado.&lt;/p&gt;

&lt;p&gt;La idea con mi librería es &lt;strong&gt;no tener que modificar código de PHPUnit&lt;/strong&gt; para que podamos seguir actualizando el framework sin miedo a perder cambios. Por tanto todo son clases nuevas y hasta un ejecutable nuevo, que nos evita tocar nada de PHPUnit.&lt;/p&gt;

&lt;p&gt;PHPUnit nos ofrece una serie de &lt;a title=&#34;Extending PHPUnit&#34; href=&#34;http://phpunit.de/manual/3.7/en/extending-phpunit.html&#34; target=&#34;_blank&#34;&gt;mecanismos para añadir o cambiar funcionalidad existente del framework&lt;/a&gt;, pero realmente &lt;strong&gt;son una mierda &lt;/strong&gt;(por lo menos en su versión actual 3.7). Nos permite extender clases para sobrescribir comportamiento, pero no da un mecanismo fácil (por configuración, por ejemplo) para decirle que utilice las nuevas clases que acabamos de crear. Debido a esto, la solución final implica que haya que utilizar un nuevo ejecutable incluído en mi librería llamado &lt;code&gt;phpunit-randomizer&lt;/code&gt;, en vez del &lt;code&gt;phpunit&lt;/code&gt; que viene por defecto con el framework.&lt;/p&gt;

&lt;p&gt;Podéis coger la librería &lt;a title=&#34;PHPUnitRandomizer&#34; href=&#34;https://github.com/fiunchinho/phpunit-randomizer&#34; target=&#34;_blank&#34;&gt;PHPUnitRandomizer en github&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>